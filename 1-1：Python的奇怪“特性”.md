## 一、浮点运算
### 1.问题的发现
    先来个Python中普通的浮点计算例子：
        >>>num = 0.1*10
        >>>print(num)
        1.0
        >>>type(num)
        <class 'float'>
    以上代码结果正常没有问题，直到我开始写毕业论文……那时我需要求解一个抛物型偏微分方程，打算采用C-N格式求解。
    选择使用Python，快速把算法构建好，把参数丢进去，开始跑。
    结果却大大偏离预期，绘制出来的图像和预想的图像有很大的不同，而且结果违背物理常识。
    熬夜排查，结果发现是一个很诡异的问题，算法涉及迭代，而循环里有个算式是：
        >>>C = A*B
    第一次迭代时A取0.0006，B取10000，预计结果为6，但是输出很奇怪：
        >>>C = A*B
        5.999999999999999
    （啊？这啥啊？怎么肥四？）
### 2.寻找原因
    后来，在命令行中输入：
        >>>0.99999999999999999 == 1.0
        True
    emmmmm……这……
    其实大佬们应该反应过来了，因为Pyhton采用的是双精度64位来保存浮点数的，而且保存的是二进制数据。
    这就导致某些数据转化为二进制后，其长度超过64位，导致数据被截断而产生误差。
    这就是原因了，那么现在要想办法解决它。
### 3.寻找解决方法
    解决的方法有很多，第一个想法就是四舍五入。
    当时我说出这个想法这个宿舍都沸腾了，多么天才的想法5.9999……四舍五入就是6，成了，完美解决。
    然后我们看到了极其离谱的迭代结果和诸如4.8 = 5，3.2 = 3这样计算结果。行吧，方案一失败。
    我们没有放弃，在智商重新上线后突然想到，
    
